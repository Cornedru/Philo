Philo :


s'assurer que les args sont ok genre assez args si cest tous des chiffres      OK
mutex = verou protege les donnes partages contre lacces concurrent
thread = ressources a la quelle on veut acceder permet lexecution concurrentes dans un programme 


toujours verouiller les mutex dans le meme ordres dans tous les thread
utiliser un timeout ou une logiquee de detection de deadlock


main est un thread mais je peut en cre dautre pour exec des fonctions en parallalele 

*thinking*

commencer par faire tourner un philo :

• le faire manger sans penser ni dormir 
• le faire penser sans manger ni dormir 
• le faire dormir sans mager ni penser

regles :
• il y a autant de philo que de fourchette (FphiloFphiloFphiloFphilo) 4 philo 4 Fourchettes

pour manger il doit avoir 2 fourchette :

	- pour avoir 2 fourchette il doit les unlock
	-  unlock celle de gauche et celle de droite 
	- puis lorsquil fini il doit le reposer 

quand il fini de manger il dort, lorquil fini de dormir (se reveille) il commence a penser puis remanger puis redort etc.. (Donc il commence par penser puis mager puis dormir)
 la simulation se fini lorsqun philo meur de faim (famine)

tous les philo doivent manger
il ne doivent pas communiquer entre eux ? 
il ne doivent pas savoir si lun ou lautre meurt



structure philo qui contient :
• le nombre de philo
• le temps ou si il na pas manger depuis le debut de la simu ou depuis sond derneir repas il meurt 
• le temps qun philo prend pour mager (le temps ou il tiendra ces deux fourchette)
• le temps quil prend a dormir 
• *optinnel* Le nombre de repas minimum ou si chaque philo les a manger la simu sarrette (si pas ajouter la simu sarrette quand un philo meurt )

table circulaire 

philo 1
philo 2
philo 3
philo 4
philo 5

philo 1 est entre le 5 et le 2 donc ( philo 1 -> n+1 = 2 et n-1 = 4)

log du programme

time in mx *num du philo* a pris une fourchette 
time in mx *num du philo* en train de manger
time in mx *num du philo* en train de dormir 
time in mx *num du philo* en train de penser 
time in mx *num du philo* mort 

les messages de doivent pas se chevaucher
le message de mort doit safficher dans les 10 ms


pas de data race ??

cault volt po

time to die to eat to sleep 0

parse_args() → init_data() → init_philos()
→ start_threads() → routine() (vie du philo)
→ monitor() → join() → cleanup()

Récupéré les paramètres (nbr de philosophes, temps à mourir, manger, dormir, etc.)

Vérifié leur validité (et converti en int)

Initialisé ta t_data via init_data

    Les philosophes avec un id pair prennent d'abord la fourchette de gauche, puis la droite.

    Ceux avec un id impair prennent d'abord la fourchette de droite, puis la gauche.

Ça évite le blocage mutuel


Une fois qu’il a mangé Il relâche les deux fourchettes = il déverrouille les mutex

pthread_mutex_unlock(&philo->data->forks[*****])
pthread_mutex_unlock(&philo->data->forks[*****])


Une fourchette à gauche (ex: forks[i])

Une fourchette à droite (ex: forks[(i + 1) % nbr]) – le modulo permet de revenir au début pour le dernier philosophe



data->print

    But : empecher que plusieurs philosophes fassent des printf en même temps.

     Sinon les messages s'entremêlent dans le terminal.


data->death_mutex

    But : protéger la variable data->dead.

    lusieurs threads peuvent vouloir lire ou écrire cette variable en même temps (pour savoir si la simulatoin continue)


data->meal_mutex 

    But : synchr l’accès aux données liées aux repas.

   pour que les threads ne lisnet ou n’écrivent pas le temps du dernier repas en meme temps

fonctions pour tous faire peter en prenant i en tous peter avant i et les malloc aussi (tous ce qui a etais allouer)



main :
	- parse args , init data , init philo
		return 1
	i < nbr
	create philos[i].trhead, null, routine, philos[i]
pthread create monitor, null monitor, routine, philo
	i < nbr
	join philo i++.trhread,null
join monitor, null


init :
intit data
	- mutex init (data->mutex, NULL)
	i < nbr
	malloc data fork * data nbr
	mutex init data->forks,null

init philos
malloc philo * data nbr
i < nbr
(*philos)[i].id = i + 1
				=0
				=0
				=data 
i++;	


routine :

take fork 

eat sleep think



*/proteger toutes les initialisation/* 



initialiser tous les mutex tous

lancer les threads

la routine
join tous les trhead
bousiller tous les mutex



int check_death(t_philo *philo)
{
    pthread_mutex_lock(&philo->data->death_mutex);
    if (philo->data->someone_died)
    {
        pthread_mutex_unlock(&philo->data->death_mutex);
        return (1);
    }
    pthread_mutex_unlock(&philo->data->death_mutex);
    return (0);
}
/* Fonction pour vérifier si tous les philosophes ont assez mangé */
int all_ate_enough(t_data *data)
{
    int i;
    int count;
    if (data->config.must_eat_count < 0)
        return (0);
    
    count = 0;
    i = 0;
    while (i < data->config.nbr_philos)
    {
        if (data->philos[i].meals_eaten >= data->config.must_eat_count)
            count++;
        i++;
    }
    return (count == data->config.nbr_philos);
}
/* Actions des philosophes */
void philo_eat(t_philo *philo)
{
    /* Prendre les fourchettes */
    if (philo->id % 2 == 0)
    {
        pthread_mutex_lock(philo->right_fork);
        print_status(philo, "has taken a fork");
        pthread_mutex_lock(philo->left_fork);
        print_status(philo, "has taken a fork");
    }
    else
    {
        pthread_mutex_lock(philo->left_fork);
        print_status(philo, "has taken a fork");
        pthread_mutex_lock(philo->right_fork);
        print_status(philo, "has taken a fork");
    }
    /* Manger */
    print_status(philo, "is eating");
    philo->last_meal_time = get_time_in_ms();
    precise_sleep(philo->data->config.time_to_eat);
    philo->meals_eaten++;
    
    /* Relâcher les fourchettes */
    pthread_mutex_unlock(philo->left_fork);
    pthread_mutex_unlock(philo->right_fork);
}
/* Routine d'un philosophe */
void *philo_routine(void *arg)
{
    t_philo *philo;
    philo = (t_philo *)arg;
    
    /* Attendre que tous les philosophes soient prêts */
    while (elapsed_time(philo->data->config.start_time) <= 0)
        usleep(100);
    
    /* Si le philosophe est seul, il ne peut pas manger */
    if (philo->data->config.nbr_philos == 1)
    {
        print_status(philo, "has taken a fork");
        return (NULL);
    }
    
    /* Décaler le départ des philosophes pairs pour éviter la famine */
    if (philo->id % 2 == 0)
        usleep(1000);
    
    /* Boucle principale du philosophe */
    while (!check_death(philo))
    {
        philo_eat(philo);
        if (all_ate_enough(philo->data))
            break;
        print_status(philo, "is sleeping");
        precise_sleep(philo->data->config.time_to_sleep);
        print_status(philo, "is thinking");
    }
    return (NULL);
}
/* Fonction de surveillance pour vérifier si un philosophe meurt */
void *monitor_routine(void *arg)
{
    t_data *data;
    int i;
    long long time_since_last_meal;
    data = (t_data *)arg;
    while (!all_ate_enough(data))
    {
        i = 0;
        while (i < data->config.nbr_philos)
        {
            time_since_last_meal = get_time_in_ms() - data->philos[i].last_meal_time;
            if (time_since_last_meal > data->config.time_to_die)
            {
                print_status(&data->philos[i], "died");
                pthread_mutex_lock(&data->death_mutex);
                data->someone_died = 1;
                pthread_mutex_unlock(&data->death_mutex);
                return (NULL);
            }
            i++;
        }
        usleep(1000);
    }
    return (NULL);
}
 
 
int start_simulation(t_data *data)
{
    int i;
    pthread_t monitor;
    
    data->config.start_time = get_time_in_ms() + (data->config.nbr_philos * 10);
    
    /* Lancement des threads des philosophes */
    i = 0;
    while (i < data->config.nbr_philos)
    {
        if (pthread_create(&data->philos[i].thread, NULL, philo_routine, &data->philos[i]) != 0)
            return (1);
        i++;
    }
    
    /* Lancement du thread de surveillance */
    if (pthread_create(&monitor, NULL, monitor_routine, data) != 0)
        return (1);
    
    /* Attente de la fin des threads */
    i = 0;
    while (i < data->config.nbr_philos)
    {
        if (pthread_join(data->philos[i].thread, NULL) != 0)
            return (1);
        i++;
    }
    
    if (pthread_join(monitor, NULL) != 0)
        return (1);
    
    return (0);
}
/* Nettoyage des ressources */
void cleanup(t_data *data)
{
    int i;
    
    i = 0;
    while (i < data->config.nbr_philos)
    {
        pthread_mutex_destroy(&data->forks[i]);
        i++;
    }
    
    pthread_mutex_destroy(&data->write_mutex);
    pthread_mutex_destroy(&data->death_mutex);
    
    free(data->philos);
    free(data->forks);
}
 
int main(int argc, char **argv)
{
    t_data data;
    
    if (check_args(argc, argv))
        return (1);
    
    if (init_data(&data, argc, argv))
    {
        printf("Error: Failed to initialize data\n");
        return (1);
    }
    
    init_philos(&data);
    
    if (start_simulation(&data))
    {
        printf("Error: Failed to start simulation\n");
        cleanup(&data);
        return (1);
    }
    
    cleanup(&data);
    return (0);
}
